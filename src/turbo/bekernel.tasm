; BefOS Kernel BEKERNEL.COM v1999.03.28 (c)1999 Cat's-Eye Technologies.

IDEAL
P8086
MODEL TINY

WORK_LIGHT	EQU	0ee0ah
OK_LIGHT	EQU	02a0ah
BAD_LIGHT	EQU	0cc0ah
EDIT_LIGHT	EQU	099b0h

DATASEG
	;---------WORK----------;
cluster		dw 0010h	; current cluster
bufptr		dw 0000h	; current byte in the current cluster
bdevice		dw 0000h	; current illogical device number
lastmove	dw BufRight	; last direction cursor moved
	;--------OPTIONS--------;
bits		db 00h		; 01 bit 0 - Edit Mode
				; 02 bit 1
				; 04 bit 2 - High if under DOS
				; 08 bit 3 - Stringmode
				; 10 bit 4
				; 20 bit 5
				; 40 bit 6
				; 80 bit 7
vpage		db 00
coybyte		db 01
beeblequit	db 00
hoffs		dw 160		; number of heading lines displayed, in offset (1 line = 160)
timerSegment	dw 0
timerOffset	dw 0
comSegment	dw 0
comOffset	dw 0
breakSegment	dw 0
breakOffset	dw 0
prtscSegment	dw 0
prtscOffset	dw 0

	;---------VIDEO---------;
ALIGN
vbase		dw 0b800h	; next page = 0b900h?
pixbase		dw 0a000h
	;---------GDT-----------;
ALIGN
gdt		db 16 dup (0)
srclen		dw 0
srcaddr		dw 0
		db 0
srcacc		db 93h
srchigh		dw 0
destlen		dw 0
destaddr	dw 0
		db 0
destacc		db 93h
desthigh	dw 0
gdtpad		db 16 dup (0)
	;-----BefOS "STACK"-----;
ossp		dw 0
	;-----Key Bindings------;

INCLUDE "inc/befkeys.inc"

	;-----Beeblebrox Bindings---;

INCLUDE "inc/beeble.inc"

; variables used by line
; int i,dx,dy,sdx,sdy,dxabs,dyabs,x,y,px,py;  
ldx		dw	0
ldy		dw	0
lsdx		dw	0
lsdy		dw	0
ldxabs		dw	0
ldyabs		dw	0
lx		dw	0
ly		dw	0
lpx		dw	0
lpy		dw	0
lcol		db	0

	;----------DISK---------;
sectrk		dw 18		; sectors per track
bytesec 	dw 512		; bytes per sector
numhead		dw 2		; number of heads
	;---------BUFFERS-------;
cbuffer 	db 2000 dup (?)	; cluster data buffer
cheader		db 48 dup (?)   ; cluster header buffer
bbuffer 	db 2048 dup (?)	; backup cluster buffer
obuffer		db 2048 dup (?) ; memory copy of colour buffer
combuf		db 2048 dup (?)	; communications port buffer
	;-------KEYBOARD--------;
keyhit		dw ?		; BIOS code for last key hit
shiftflags	dw ?		; shift flags for last key hit
	;----------RAM----------;
basek		dw ?		; non-extended kilobytes
extk		dw ?		; extended kilobytes
	;-----SYSTEM STACK------;
osstack		dw 256 dup (?) ; BefOS system stack

comhandle	dw ?
temp		dw ?
temp2		dw ?
templen		dw ?
attr		db ?

CODESEG
ORG 0100h  ; strictly necessary

PROC    MAIN
Start:
;-FIX DATA SEGMENT----------------------;
		jmp	short	GoBefOS

		jmp	BindFunc	; always at cs:0102h

GoBefOS:	mov	ax, cs
		mov	ds, ax		; fix data segment
		mov	ss, ax		; fix stack segment
		mov	sp, 0fffeh

		mov	ax, 1200h
		int	2fh
		cmp	al, 0ffh		; not if there's no DOS!
		je	@@DOS
		jmp	@@Video

@@DOS:		or	[byte bits], 04h	; notify BefOS
		mov	ax, cs			; allocate some memory
		add	ax, 400h		; main prog/data = 16K
		mov	[word runseg+3], ax	; modify the far call!

;-VIDEO---------------------------------;
@@Video:	mov	ax, 0500h
		int	10h
		mov	ah, 15
		int	10h
		cmp	al, 7
		jne	@@SPSH
		mov	[word vbase], 0b000h
;-SPLASH--------------------------------;
@@SPSH:		call	TextVid
		mov	cl, 2fh
		call	ClrScreen

;-RAM-----------------------------------;
@@RAM:		int	12h			; get avail base mem in k
		mov	[word basek], ax

		mov	ax, 8800h
		int	15h			; SYSTEM - GET EXTENDED MEMORY SIZE (286+)
		mov	[word extk], ax

		call	RefreshStatus
		call	LoadClust
		call	MoveCursor

;-ISRs----------------------------------;

		call	PlugBreak
		call	PlugPrtSc

;-SELECT--------------------------------;

@@Select:	call	GetKey

		mov	ax, [word keyhit]
		cmp	al, 0
		jne	@@ASCIIKey
		cmp	ah, 3
		je	@@ASCIIKey		; Ctrl-2!
		xor	bx, bx
		mov	bl, ah
		shl	bx, 1
		mov	si, bx
		mov	ax, [word keytab + si]
		call	ax
		jmp	@@Select

@@ASCIIKey:	test	[byte bits], 01h
		jz	@@NoWrite
		mov	cx, [word keyhit]
		call	WriteByte
		call	Advance
		jmp	@@Select

@@NoWrite:	call	BadLight
		jmp	@@Select

ENDP

;=============PROCS=============;

PUBLIC	BindFunc
PROC	BindFunc
; es:si -> null-terminated string, naming the desired function
; returns bx = BefOS function pointer

; 1 treeptr x = root;

		; mov	bx, offset root

; 2 if x == NULL abort

@@Loop:		cmp	bx, 0
		jne	@@SallyForth
		mov	bx, offset Unimp
		ret

@@SallyForth:	

; 3 mov di, x->key

		mov	di, [word bx + 6]

; 4 strcmp es:si, ds:di

		mov	al, [byte es:si]
		mov	dl, [byte ds:di]
		cmp	al, dl
		ja	@@Right
		; ...

; 5 if si < di, x = x->left, goto 2

		mov	bx, [word bx]
		jmp	@@Loop

; 6 if si > di, x = x->right, goto 2

@@Right:	mov	bx, [word bx + 2]
		jmp	@@Loop

; return x->functionptr

		mov	bx, [word bx + 2]
		ret

ENDP

PROC	EditModeOnly
; ax may be destroyed
		test	[byte bits], 01h
		jnz	@@Return
FallThru:	call	BadLight
		pop	ax
@@Return:	ret
ENDP

PROC	NotInEditMode
; ax may be destroyed
		test	[byte bits], 01h
		jz	@@Return
		pop	ax
@@Return:	ret
ENDP

PROC	DOSOnly
; ax may be destroyed
		test	[byte bits], 04h
		jz	FallThru
		ret
ENDP

PROC 	NotUnderDOS
; ax may be destroyed
		test	[byte bits], 04h
		jnz	FallThru
		ret
ENDP

PUBLIC	Unimp
PROC	Unimp
		jmp	BadLight
ENDP

PUBLIC	SysCall
PROC	SysCall
; SysCall - this is called far only by BefOS applications.

; ax = destroyed
; bx = function number

		mov	ax, cs
		mov	ds, ax
		call	bx
		retf
ENDP SysCall

PUBLIC	TextVidBase
PROC	TextVidBase
		mov	es, [word vbase]
		ret
ENDP
PUBLIC	PixVidBase
PROC	PixVidBase
		mov	es, [word pixbase]
		ret
ENDP

PUBLIC	TextVid
PROC	TextVid

		; TODO: determine if the text video page is already active;
		; if so, only swap pages with TextVidPage.
		; this will reduce flicker on return to OS from application.

	        mov     ax, 0003h
        	int	10h
		mov     ax, 0500h
		int	10h
		mov	[byte vpage], 0

;		mov	ax, ds
;		mov	es, ax
;		mov	ax, 1100h
;		mov	bp, offset charset
;		mov	cx, 256		; num of chars to be reimaged
;		mov	dx, 0		; first char num to be reimaged
;		mov	bl, 0		; block to load in "map 2"
;		mov	bh, 16		; bytes per char-image
;		int	10h

		call	TextVidBase
	        call	OKLight
		call	RefreshStatus
		jmp	DisplayClust
ENDP

PUBLIC	PixVid
PROC	PixVid
        	mov     ax, 0013h
	        int	10h
        	jmp	PixVidBase
ENDP

PUBLIC	NextTextVidPage
PROC	NextTextVidPage
		mov	al, [byte vpage]
		inc	al
		and	al, 7
		mov	[byte vpage], al
		mov     ah, 05h
		int	10h
		ret
ENDP

PUBLIC	PrevTextVidPage
PROC	PrevTextVidPage
		mov	al, [byte vpage]
		dec	al
		and	al, 7
		mov	[byte vpage], al
		mov     ah, 05h
		int	10h
		ret
ENDP

PUBLIC	PushWord
PROC	PushWord
		mov	bx, [word ossp]
		mov	[word bx + offset osstack], cx
		inc	[word ossp]
		ret
ENDP

PUBLIC	PopWord
PROC	PopWord
		dec	[word ossp]
		mov	bx, [word ossp]
		mov	cx, [word bx + offset osstack]
		ret
ENDP

PUBLIC	PushHexInstr
PROC	PushHexInstr
		mov	bx, [word bufptr]
		xor	ch, ch
		mov	cl, [byte offset cbuffer + bx]
		sub	cl, 'a'
		jmp	PushWord
ENDP

PUBLIC	AddWords
PROC	AddWords
		call	PopWord
		mov	ax, cx
		call	PopWord
		add	ax, cx
		mov	cx, ax
		jmp	PushWord
ENDP

PUBLIC	SubWords
PROC	SubWords
		call	PopWord
		mov	ax, cx
		call	PopWord
		sub	ax, cx
		mov	cx, ax
		jmp	PushWord
ENDP

PUBLIC	MulWords
PROC	MulWords
		call	PopWord
		mov	ax, cx
		call	PopWord
		mul	cx
		mov	cx, ax
		jmp	PushWord
ENDP

PUBLIC	DivWords
PROC	DivWords
		call	PopWord
		mov	ax, cx
		call	PopWord
		div	cx
		mov	cx, ax
		jmp	PushWord
ENDP

PUBLIC	GetKey
PROC	GetKey

		mov	ah, 12h
		int	16h		; get key shift states

		mov	[word shiftflags], ax

		mov	cx, ax
		call	StatusWord

; Notes: AL bit 3 set only for left Alt key on many machines.
; AH bits 7 through 4 always clear on a Compaq SLT/286.
; INT 16/AH=09h should be used to determine whether this function
; is supported.

; Bitfields for _al_
;Bit(s)  Description     (Table 00587)
;7      Insert active
;6      CapsLock active
;5      NumLock active
;4      ScrollLock active
;3      Alt key pressed (either Alt on 101/102-key keyboards)
;2      Ctrl key pressed (either Ctrl on 101/102-key keyboards)
;1      left shift key pressed
;0      right shift key pressed

;Bitfields for _ah_
;Bit(s)  Description     (Table 00588)
;7      SysReq key pressed (SysReq is often labeled SysRq)
;6      CapsLock pressed
;5      NumLock pressed
;4      ScrollLock pressed
;3      right Alt key pressed
;2      right Ctrl key pressed
;1      left Alt key pressed
;0      left Ctrl key pressed

		xor	ah, ah			; get a key
		int	16h
		mov	[word keyhit], ax

		cmp	[word hoffs], 0
		je	@@SkipKey

		call	TextVidBase
		mov	bx, ax
		mov	ah, 70h
		mov	di, 140
		call	DisplayShort

		mov	cx, [word keyhit]
@@SkipKey:	ret
ENDP

PUBLIC	ReadKey
PROC	ReadKey

		xor	ah, ah			; check for outstanding key
		inc	ah
		int	16h
		jz	@@NoKey
		jmp	GetKey
@@NoKey:	xor	cx, cx
		ret
ENDP

PUBLIC	ReadByte
PROC	ReadByte
		xor	cx, cx
		mov	di, [word bufptr]
		mov	cl, [byte cbuffer + di]
		ret
ENDP

PUBLIC	WriteByte
PROC	WriteByte
		mov	si, [word bufptr]
		mov	[byte cbuffer + si], cl
		call	TextVidBase
		mov	bx, si
		shl	bx, 1
		add	bx, [word hoffs]
		mov	si, bx
		mov	ch, 71h
		mov	[word es:si], cx
		ret
ENDP

PUBLIC	BufHome
PROC	BufHome
		mov	[word bufptr], 0
		jmp	MoveCursor
ENDP

PUBLIC	Beeblebrox
PROC	Beeblebrox

		xor	al, al
		mov	[byte beeblequit], al

@@Loop:		mov	al, [byte beeblequit]
		cmp	al, 0
		jne	@@BeebleQuit
		call	ExecBeebInstr
		jmp	@@Loop
@@BeebleQuit:	ret
ENDP

PUBLIC	EndBeeblebrox
PROC	EndBeeblebrox

		mov	[byte beeblequit], 1
		ret
ENDP

PUBLIC	ExecBeebInstr
PROC	ExecBeebInstr

		mov	di, [word bufptr]
		xor	bh, bh
		mov	bl, [byte offset cbuffer + di]

		shl	bx, 1
		mov	ax, [offset scripttab + bx]
		call	ax
		jmp	Advance
ENDP

PUBLIC	Advance
PROC	Advance
		mov	ax, [word lastmove]
		jmp	ax
ENDP

PUBLIC	MoreScreen
PROC	MoreScreen
		cmp	[word hoffs], 0
		ja	@@LessHeader
		ret
@@LessHeader:	sub	[word hoffs], 160
		jmp	DisplayClust
ENDP

PUBLIC	LessScreen
PROC	LessScreen
		cmp	[word hoffs], 2560
		jb	@@MoreHeader
		ret
@@MoreHeader:	add	[word hoffs], 160

		mov	ax, [word bufptr]
		mov	bx, [word hoffs]
		shr	bx, 1
		add	ax, bx
		cmp	ax, 2000
		jb	@@InRange

		sub	[word bufptr], 80

@@InRange:	cmp	[word hoffs], 320
		jae	@@Blanks
		cmp	[word hoffs], 160
		jne	@@StillOn
		call	OKLight
		call	RefreshStatus
@@StillOn:	jmp	DisplayClust
@@Blanks:
		call	TextVidBase
		mov	si, 160
@@Bloop:	mov	[word es:si], 2020h
		inc	si
		inc	si
		cmp	si, [word hoffs]
		jne	@@Bloop
		jmp	DisplayClust
ENDP

PUBLIC	RefreshStatus
PROC	RefreshStatus
		call	TextVidBase
		mov	di, 0
		mov	[word es:di], 02f42h	; the BefOS 'logo'

		mov	di, 4
		mov	bx, [word basek]
		mov	ah, 07h
		call	DisplayShort

		mov	bx, [word extk]
		mov	ah, 70h
		call	DisplayShort

		mov	bx, [word keyhit]
		mov	ah, 70h
		mov	di, 140
		call	DisplayShort

		mov	ah, 03h
		mov	bx, [word cluster]	; Display cluster number onscreen
		mov	di, 152
		jmp	DisplayShort
ENDP

PUBLIC	HighBit
PROC	HighBit
		call	EditModeOnly
		mov	bx, [word bufptr]
		mov	cl, [byte cbuffer + bx]
		xor	cl, 80h
		mov	[byte cbuffer + bx], cl
		jmp	ShowByte
ENDP

PUBLIC	StringMode
PROC	StringMode
		jmp	Unimp
ENDP

PUBLIC	NextDev
PROC	NextDev
		call	NotInEditMode
		inc	[word bdevice]
		cmp	[word bdevice], 2	; 2 devices?!?
		jne	@@Return
		mov	[word bdevice], 0
@@Return:	jmp	LoadClust
ENDP

PUBLIC	PrevDev
PROC	PrevDev
		call	NotInEditMode
		dec	[word bdevice]
		cmp	[word bdevice], 0ffffh
		jne	@@Return
		mov	[word bdevice], 1
@@Return:	jmp	LoadClust
ENDP

PUBLIC	ClustUp
PROC	ClustUp
		call	NotInEditMode
		inc	[word cluster]
		cmp	[word cluster], 720	; 720 clusters
		jne	@@Return
		mov	[word cluster], 0
@@Return:	jmp	LoadClust
ENDP


PUBLIC	ClustDown
PROC	ClustDown
		call	NotInEditMode
		dec	[word cluster]
		cmp	[word cluster], 0ffffh
		jne	@@Return
		mov	[word cluster], 719
@@Return:	jmp	LoadClust
ENDP

PUBLIC	NextClust
PROC	NextClust
		mov	cx, [word cheader+2]
HyperClust:	cmp	cx, 0
		je	@@Abort
		jmp	GoClust
@@Abort:	jmp	BadLight
ENDP

PUBLIC	PrevClust
PROC	PrevClust
		mov	cx, [word cheader+4]
		jmp	HyperClust
ENDP

PUBLIC	HelpClust
PROC	HelpClust
		mov	cx, [word cheader+10]
		jmp	HyperClust
ENDP

PUBLIC	ColourClust
PROC	ColourClust
		mov	cx, [word cheader+8]
		jmp	HyperClust
ENDP

PUBLIC	BufRight
PROC	BufRight
		mov	[word lastmove], offset BufRight
BufHopRight:	inc	[word bufptr]
		mov	ax, 2000
		mov	bx, [word hoffs]
		shr	bx, 1
		sub	ax, bx
		cmp	[word bufptr], ax
		jne	@@Return
		mov	[word bufptr], 0
@@Return:	jmp	MoveCursor
ENDP


PUBLIC	BufLeft
PROC	BufLeft
		mov	[word lastmove], offset BufLeft
BufHopLeft:	dec	[word bufptr]
		cmp	[word bufptr], 0ffffh
		jne	@@Return
		mov	ax, 2000
		mov	bx, [word hoffs]
		shr	bx, 1
		sub	ax, bx
		dec	ax
		mov	[word bufptr], ax
@@Return:	jmp	MoveCursor
ENDP

PUBLIC	BufUp
PROC	BufUp
		mov	[word lastmove], offset BufUp
BufHopUp:	sub	[word bufptr], 80
		cmp	[word bufptr], 0
		jge	@@Return
		mov	ax, 2000
		mov	bx, [word hoffs]
		shr	bx, 1
		sub	ax, bx
		add	[word bufptr], ax
@@Return:	jmp	MoveCursor
ENDP


PUBLIC	BufDown
PROC	BufDown
		mov	[word lastmove], offset BufDown
BufHopDown:	add	[word bufptr], 80
		mov	ax, 2000
		mov	bx, [word hoffs]
		shr	bx, 1
		sub	ax, bx
		cmp	[word bufptr], ax
		jl	@@Return
		sub	[word bufptr], ax
@@Return:	jmp	MoveCursor
ENDP

PUBLIC	LineFeed
PROC	LineFeed
; just like BufDown except invokes a scroll if on bottom line.
		add	[word bufptr], 80
		mov	ax, 2000
		mov	bx, [word hoffs]
		shr	bx, 1
		sub	ax, bx
		cmp	[word bufptr], ax
		jl	@@Return
		sub	[word bufptr], 80 ; back to where we once belonged

		; get top line of screen = hoffs/160
		mov	ax, bx
		mov	bx, 80
		xor	dx, dx		; Zero high!
		div	bx

		xor	cx, cx
		mov	ch, al

		; scroll area on screen

		mov	ax, 0601h
		mov	bh, 27h		; todo: better attribute... need var
		mov	dx, 184fh	; (79,24)
		int	10h		; scroll it

@@Return:	jmp	MoveCursor
ENDP

PUBLIC	LeftMarg
PROC	LeftMarg
		mov	ax, [word bufptr]
		mov	bx, 80
		xor	dx, dx		; Zero high!
		div	bx

		xor	ah, ah
		shl	ax, 4
		mov	bx, ax
		shl	bx, 2
		add	ax, bx

		mov	[word bufptr], ax

		jmp	MoveCursor
ENDP

PUBLIC	Shutdown
PROC	Shutdown
; Under DOS, quits to DOS.
; As true BefOS, may reboot or shut down the system.

		call	DOSOnly
		call	NotInEditMode

		call	UnplugClock
		;call	UnplugCom
		call	UnplugPrtSc
		call	UnplugBreak

		mov	cl, 07h			; clear me!
		call	ClrScreen

		xor	ah, ah			; reset
		xor	dl, dl			; disk 0
		int	13h

		mov	ax, 4c00h
		int	21h			; exit
ENDP

PUBLIC	ImpClust
PROC	ImpClust
; Import a file into a cluster, only under DOS.

		call	DOSOnly
		call	EditModeOnly

		mov	dx, offset cbuffer
		mov	ah, 3dh		; open the file
		mov	al, 0		; 0 = read only
		int	21h
		jnc	@@GotFile
		jmp	BadLight

@@GotFile:	mov	[comhandle], ax

		mov	ah, 3fh		; read
		mov	bx, [comhandle]	; from handle
                mov     cx, 2048        ; the .COM file
		mov	dx, offset cbuffer
		int	21h
		jnc	@@Close
@@LocalFail:	jmp	BadLight

@@Close:	mov	bx, [comhandle]
		mov	ah, 3eh
		int	21h
		jc	@@LocalFail

		jmp	DisplayClust


ENDP

PUBLIC	DeviceInfo
PROC	DeviceInfo

		mov	ah, 15h
		mov	bx, [word bufptr]
		mov	dl, [byte cbuffer + bx]
		int	13h		; DISK - GET DISK TYPE
		jc	@@Error

		push	cx
		push	dx

		call	TextVidBase

		mov	ah, 5fh
		pop	bx
		mov	di, 124
		call	DisplayShort
		pop	bx
		call	DisplayShort

		jmp	OKLight

@@Error:	jmp	BadLight

ENDP

PUBLIC	ClrScreen
PROC	ClrScreen
		mov	bh, cl
		xor	cx, cx			; (0,0)-
		mov	dx, 184fh		; (79,24)
		mov	ax, 0600h		; BIOS clear rectangle
		int	10h
		ret
ENDP

PROC	UpdateCurByte ; on the status bar

		cmp	[word hoffs], 0
		ja	@@OKGO
		ret

@@OKGO:		mov	di, [word bufptr]
		mov	bl, [byte cbuffer + di]

		mov	ah, 1fh
		mov	di, 148
		jmp	DisplayByte
ENDP

PROC	MoveCursor
; MoveCursor - moves cursor to reflect bufptr.
;   ax=DESTROYED
;   bx=DESTROYED
;   dx=DESTROYED

		xor	dx, dx
		mov	ax, [word bufptr]
		mov	bx, [word hoffs]
		shr	bx, 1
		add	ax, bx
		mov	bx, 80
		div	bx

		mov	dh, al

		mov	ah, 02h
		mov	bh, 00h

		int	10h			; cursor gotoxy
		jmp	UpdateCurByte

ENDP

PUBLIC	MoveCrsr
PROC	MoveCrsr
		mov	[word bufptr], cx
		jmp	MoveCursor
ENDP

PROC	DisplayProperties
; ax,si,di=DESTROYED

		cmp	[word hoffs], 0
		ja	@@OKGO
		jmp	MoveCursor

@@OKGO:		mov	di, 0
@@Green:	mov	ax, di
		shl	ax, 1
		mov	si, ax			; si = di * 2
		mov	ax, 2020h
		mov	[word es:si + 20], ax
		inc	di
		cmp	di, 60
		jne	@@Green

		mov	di, 0
		cmp	[word cheader], 0bef0h	; validate header ID.
		je	@@Draw
		jmp	MoveCursor

@@Draw:		mov	ax, di			; show file description.
		shl	ax, 1
		mov	si, ax			; si = di * 2
		mov	ah, 71h
		mov	al, [byte cheader + 32 + di]
		mov	[word es:si + 100], ax
		inc	di
		cmp	di, 16
		jne	@@Draw

		mov	ah, 71h
		mov	bx, [word cheader+2]
		mov	di, 28
		call	DisplayShort

		mov	ah, 74h
		mov	bx, [word cheader+4]
		call	DisplayShort

		mov	ah, 7ah
		mov	bx, [word cheader+6]
		call	DisplayShort

		mov	ah, 7bh
		mov	bx, [word cheader+8]
		call	DisplayShort

		mov	ah, 70h
		mov	bx, [word cheader+10]
		call	DisplayShort

		jmp	MoveCursor
ENDP

PUBLIC	EditClustProps
PROC	EditClustProps
; ax,si,di=DESTROYED

		cmp	[word hoffs], 0
		ja	@@OKGO
		jmp	MoveCursor

@@OKGO:		cmp	[word cheader], 0bef0h	; first off validate header ID.
		jnz	@@Abort
		mov	di, 0
		jmp	@@Edit
@@Abort:	jmp	BadLight
@@Edit:		mov	ah, 71h
		mov	di, 100
		mov	cx, 16
		call	EditString

		mov	di, 0
@@Save:		mov	ax, di			; show file description.
		shl	ax, 1
		mov	si, ax			; si = di * 2
		mov	ax, [word es:si + 100]
		mov	[byte cheader + 32 + di], al
		inc	di
		cmp	di, 16
		jne	@@Save

		mov	ah, 71h
		mov	bx, [word cheader+2]
		push	bx
		mov	di, 28
		call	EditShort
		mov	[word cheader+2], bx

		mov	ah, 74h
		mov	bx, [word cheader+4]
		pop	bx
		call	EditShort
		mov	[word cheader+4], bx

		mov	ah, 7ah
		mov	bx, [word cheader+6]
		call	EditShort
		mov	[word cheader+6], bx

		mov	ah, 7bh
		mov	bx, [word cheader+8]
		call	EditShort
		mov	[word cheader+8], bx

		mov	ah, 70h
		mov	bx, [word cheader+10]
		call	EditShort
		mov	[word cheader+10], bx

		jmp	MoveCursor
		ret
ENDP

PUBLIC	InitClustProps
PROC	InitClustProps
; ax,si,di=DESTROYED

		mov	[word cheader], 0bef0h
		xor	ax, ax
		mov	[word cheader+2], ax
		mov	[word cheader+4], ax
		mov	[word cheader+6], ax
		mov	[word cheader+8], ax
		mov	[word cheader+10], ax
		jmp	DisplayProperties

ENDP

PUBLIC	DelClustProps
PROC	DelClustProps
		mov	[word cheader], 0000h	; invalidate the header ID.
		jmp	DisplayProperties

ENDP

PROC	DisplayClust
; DisplayClust - display memory cluster buffer on-screen
; ax,si,di=DESTROYED

		mov	di, 0
@@Draw:		mov	ax, di
		shl	ax, 1
		mov	si, ax			; si = di * 2
		mov	ah, [byte obuffer + di]
		mov	al, [byte cbuffer + di]
		add	si, [word hoffs]
		mov	[word es:si], ax
		inc	di
		mov	ax, 4000
		cmp	si, ax
		jne	@@Draw
		jmp	DisplayProperties
ENDP

PUBLIC	CopyClust
PROC	CopyClust
; CopyClust - copy cluster in memory to clipboard
; ax,di=DESTROYED

		mov	di, 0
@@Copy:		mov	ax, di
		mov	al, [byte cbuffer + di]
		mov	[byte bbuffer + di], al
		inc	di
		cmp	di, 2048
		jne	@@Copy
		jmp	OKLight
ENDP

PUBLIC	CutClust
PROC	CutClust
		call	EditModeOnly
		call	CopyClust
		jmp	FillClust
ENDP

PUBLIC	CopyByte
PROC	CopyByte
; CopyByte - copy byte from cluster to clipboard
; al,di=DESTROYED

		mov	di, [word bufptr]
		mov	al, [byte cbuffer + di]
		mov	[byte coybyte], al
		jmp	OKLight
ENDP

PUBLIC	PasteByte
PROC	PasteByte
; CopyByte - copy byte from cluster to clipboard
; al,cl,di=DESTROYED

		call	EditModeOnly
		mov	di, [word bufptr]
		mov	al, [byte coybyte]
		mov	[byte cbuffer + di], al
		mov	cl, al
		jmp	ShowByte
ENDP

PUBLIC	EditMode
PROC	EditMode
; EditMode
		or	[byte bits], 1
		jmp	EditLight
ENDP

PUBLIC	IncByte
PROC	IncByte
; IncByte
; al,cl,di=DESTROYED

		mov	al, 1
		jmp	DeltaByte
ENDP

PUBLIC	DecByte
PROC	DecByte
; DecByte
; al,cl,di=DESTROYED
		mov	al, -1
ENDP

PROC	DeltaByte
; DeltaByte
; al=delta
; cl,di=DESTROYED

		call	EditModeOnly
		mov	di, [word bufptr]
		mov	cl, [byte cbuffer + di]
		add	cl, al
		jmp	ShowByte
ENDP

PUBLIC	ShowByte
PROC	ShowByte
		call	WriteByte
		jmp	UpdateCurByte
ENDP

PUBLIC	InsByte
PROC	InsByte
; InsertByte
; ax,si,di=DESTROYED

;		mov	di, 0
;@@Draw:		mov	ax, di
;		shl	ax, 1
;		mov	si, ax			; si = di * 2
;		mov	ah, 12h
;		mov	al, [byte cbuffer + di]
;		add	si, [word hoffs]
;		mov	[word es:si], ax
;		inc	di
;		mov	ax, 4000
;		cmp	si, ax
;		jne	@@Draw
		jmp	DisplayProperties
ENDP

PUBLIC	DelByte
PROC	DelByte
; DeleteByte
; ax,si,di=DESTROYED

;		mov	di, 0
;@@Draw:		mov	ax, di
;		shl	ax, 1
;		mov	si, ax			; si = di * 2
;		mov	ah, 12h
;		mov	al, [byte cbuffer + di]
;		add	si, [word hoffs]
;		mov	[word es:si], ax
;		inc	di
;		mov	ax, 4000
;		cmp	si, ax
;		jne	@@Draw
		jmp	DisplayProperties
ENDP

PUBLIC	PasteClust
PROC	PasteClust
; PasteClust - copy cluster in clipboard to memory
; ax,di=DESTROYED

		call	EditModeOnly
		mov	di, 0
@@Copy:		mov	ax, di
		mov	al, [byte bbuffer + di]
		mov	[byte cbuffer + di], al
		inc	di
		cmp	di, 2048
		jne	@@Copy
		jmp	DisplayClust
ENDP

PUBLIC	AskGoClust
PROC	AskGoClust
; ax,si,di=DESTROYED

		call	NotInEditMode

		cmp	[word hoffs], 0
		ja	@@OKGO
		ret			; Not with no status bar

@@OKGO:		mov	ah, 03h
		mov	bx, [word cluster]
		mov	di, 152
		call	EditShort
		mov	cx, bx
		jmp	GoClustInEdit
ENDP

PUBLIC	GoClust
PROC	GoClust
		call	NotInEditMode
GoClustInEdit:	cmp	cx, 720
		jae	@@Abort
		mov	[word cluster], cx
		jmp	LoadClust
@@Abort:	call	LoadClust
		jmp	BadLight
ENDP

PUBLIC	LoadClust
PROC	LoadClust
; LoadClust - read cluster into buffer and display it

		call	WorkLight

		and	[byte bits], 0feh	; Feh! Turn off edit.

		mov	di, 0
		mov	al, 1ah
@@Fill:		mov	[byte cbuffer + di], 0	; clear cluster buffer.
		mov	[byte obuffer + di], al ; clear colour buffer
		inc	di
		cmp	di, 2000
		jne	@@Fill

		mov	ax, ds
		mov	es, ax
		mov	ax, [word cluster]
		mov	bx, offset cbuffer
		call	ReadClust

		cmp	ax, 1
		jne	@@Cnt

@@Error:	call	BadLight
		jmp	@@Status

@@Cnt:		mov	ax, [word cheader]
		cmp	ax, 0bef0h
		jne	@@OK

		mov	ax, ds
		mov	es, ax
		mov	ax, [word cheader+8]	; colour cluster number
		mov	bx, offset obuffer

		cmp	ax, 0
		je	@@OK
		call	ReadClust
		cmp	ax, 1
		je	@@Error

@@OK:		call	OKLight

@@Status:	cmp	[word hoffs], 0
		ja	@@OKGO
		jmp	DisplayClust

@@OKGO:		mov	ah, 03h
		mov	bx, [word cluster]	; Display cluster number onscreen
		mov	di, 152
		call	DisplayShort
		jmp	DisplayClust
ENDP

PUBLIC	SaveClust
PROC	SaveClust
; SaveClust - write cluster from buffer and re-display it

		call	EditModeOnly
		call	WorkLight
		and	[byte bits], 0feh	; Feh! Turn off edit.
		mov	ax, ds
		mov	es, ax
		mov	ax, [word cluster]
		mov	bx, offset cbuffer
		call	WriteClust

		cmp	ax, 1
		jne	@@OK

		call	BadLight
		jmp	@@Cnt

@@OK:		call	OKLight
		jmp	DisplayClust
@@Cnt:		ret
ENDP

; possibly one day PUBLIC
PROC	RunClust
		call	NotInEditMode
		cmp	[word cheader+6], 0ffffh
		jne	@@MayBeeble
		jmp	@@RunAsm
@@MayBeeble:	cmp	[word cheader+6], 0beebh
		jne	@@Abort
		jmp	@@RunBeeble
@@Abort:	jmp	BadLight
@@RunAsm:	mov	ax, [word runseg+3]
		mov	es, ax
		mov	di, 0100h

@@RLoop:	mov	ax, [word cbuffer - 0100h + di]
		mov	[word es:di], ax
		inc	di
		inc	di
		cmp	di, 2048 + 0100h
		jne	@@RLoop

runseg:		call	far 0800h:0100h
		mov	ax, cs
		mov	ds, ax			; reset ds
		call	TextVidBase
		ret

@@RunBeeble:	call	BufHome
		mov	[word lastmove], offset BufRight
		jmp	Beeblebrox
ENDP

PUBLIC	FillClust
PROC	FillClust
; FillClust - fill data buffer with current byte

		call	EditModeOnly
		mov	di, [word bufptr]
		mov	bl, [byte cbuffer + di]
		mov	di, 0
@@Fill:		mov	[byte cbuffer + di], bl
		inc	di
		cmp	di, 2000
		jne	@@Fill
		jmp	DisplayClust
ENDP


PUBLIC	WorkLight, BadLight, EditLight, OKLight, CustomLight
PROC	WorkLight
		mov	ax, WORK_LIGHT
		jmp	Light
ENDP
PROC	BadLight
		mov	ax, BAD_LIGHT
		jmp	Light
ENDP
PROC	EditLight
		mov	ax, EDIT_LIGHT
		jmp	Light
ENDP
PROC	OKLight
		mov	ax, OK_LIGHT
ENDP
PROC	Light
		call	TextVidBase
		mov	di, 2
		
		cmp	[word hoffs], 0
		ja	@@OKGO
		ret

@@OKGO:		mov	[word es:di], ax
		ret
ENDP

PROC	CustomLight
		mov	ax, cx
		jmp	Light
ENDP


;PROC	StoreExtClust
;
;		call	WorkLight
;
;		mov	[word srclen], 2048
;		mov	[word srcaddr], offset cbuffer
;		mov	ax, ds
;		shl	ax, 4
;		add	[word srcaddr], ax
;		mov	ax, ds
;		shr	ax, 12
;		mov	[byte srcaddr+2], al
;
;		mov	[word destlen], 2048
;		mov	[word destaddr], 0
;		mov	[byte destaddr+2], 10h
;
;		mov	ax, ds
;		mov	es, ax
;		mov	ah, 87h
;		mov	cx, 1024
;		mov	si, offset gdt
;		int	15h

;		jc	@@Error
;		jmp	OKLight
;@@Error:	jmp	BadLight
;
;ENDP

;PROC	RetrieveExtClust
;
;		call	WorkLight
;
;		mov	[word srclen], 2048
;		mov	[word srcaddr], 0
;		mov	[byte srcaddr+2], 10h

;		mov	[word destlen], 2048
;		mov	[word destaddr], offset cbuffer
;		mov	ax, ds
;		shl	ax, 4
;		add	[word destaddr], ax
;		mov	ax, ds
;		shr	ax, 12
;		mov	[byte destaddr+2], al

;		mov	ax, ds
;		mov	es, ax
;		mov	ah, 87h
;		mov	cx, 1024
;		mov	si, offset gdt
;		int	15h

;		jc	@@Error
;		call	OKLight
;		jmp	DisplayClust
;@@Error:	jmp	BadLight
;
;ENDP

PROC    ReadK
; ReadK - read two contiguous sectors from drive #0
;   ax=first sector number
;   es:bx=address of buffer (2x512 = 1024)
;   cx=DESTROYED
;   dx=DESTROYED
;   di=DESTROYED
@@Begin:
		xor	dx, dx		; Zero high
		div	[sectrk]	; Calculate track
		mov	cl, dl		; CL = sector
		inc	cl
		xor	dx, dx		; Zero high
		div	[numhead]	; Compute head
		mov	ch, al		; CH = cylinder
		mov	dh, dl		; DH = head
		xor	dl, dl		; DL = drive 0
		mov	di, 3		; Try three times
@@Read1:
		mov	ax, 0202h	; Read 2 sectors
		int	13h		; Call BIOS
                jnc     @@Read2         ; Success
		dec	di		; Reduce count
                jnz     @@Read1         ; Keep trying
		mov	ax, 1		; DISK ERROR
		ret
@@Read2:
		xor	ax, ax		; Zero return
        	ret
ENDP

PROC    WriteK
; WriteK - write two contiguous sectors to drive #0
;   ax=number of first sector
;   es:bx=address of buffer
;   cx=DESTROYED
;   dx=DESTROYED
;   di=DESTROYED

@@Begin:
		xor	dx, dx		; Zero high
		div	[sectrk]	; Calculate track
		mov	cl, dl		; CL = sector
		inc	cl		; 1-
		xor	dx, dx		; Zero high
		div	[numhead]	; Compute head
		mov	ch, al		; CH = cylinder
		mov	dh, dl		; DH = head
		xor	dl, dl		; DL = drive #0
		mov	di, 3		; Try three times
@@Write1:
		mov	ax, 0302h	; Write 2 sectors
		int	13h		; Call BIOS
                jnc     @@Write2        ; Success
		dec	di		; Reduce count
                jnz     @@Write1        ; Keep trying
		mov	ax, 1		; DISK ERROR
		ret
@@Write2:
		xor	ax, ax		; Zero return
		ret
ENDP


PROC    ReadClust
; ReadClust - read a cluster from drive #0
;   ax=cluster number
;   es:bx=address of buffer (4x512 = 2048!)
;   cx=DESTROYED
;   dx=DESTROYED
;   di=DESTROYED
@@Begin:
		shl	ax, 1
		shl	ax, 1
		mov	[temp], ax
		call	ReadK
		mov	ax, [temp]
		inc	ax
		inc	ax
		add	bx, 1024
		call	ReadK
		ret
ENDP

PROC    WriteClust
; WriteClust - write a cluster to drive #0
;   ax=cluster number
;   es:bx=address of buffer
;   cx=DESTROYED
;   dx=DESTROYED
;   di=DESTROYED

@@Begin:
		shl	ax, 1
		shl	ax, 1
		mov	[temp], ax
		call	WriteK
		mov	ax, [temp]
		inc	ax
		inc	ax
		add	bx, 1024
		call	WriteK
		ret
ENDP


PROC    DisplayByte
; DisplayByte - show an 8-bit unsigned value as onscreen hex
;   ah=attributes, al=DESTROYED
;   bl=number to display
;   di=location on screen- INCREMENTED
;   cl=DESTROYED

		mov	al, bl
		and	al, 0f0h
		mov	cl, 4
		shr	al, cl

		cmp	al, 10
		jge	@@Hex

		add	al, '0'
		jmp	@@Then

@@Hex:		add	al, 'a'-10
@@Then:		mov	[word es:di], ax
		inc	di
		inc	di

		mov	al, bl
		and	al, 0fh

		cmp	al, 10
		jge	@@Hex2

		add	al, '0'
		jmp	@@Then2

@@Hex2:		add	al, 'a'-10
@@Then2:	mov	[word es:di], ax
		inc	di
		inc	di

		ret
ENDP

PROC    DisplayShort
; DisplayShort - show a 16-bit unsigned value as onscreen hex
;   ah=attributes, al=DESTROYED
;   bx=number to display
;   di=location on screen- INCREMENTED
;   cl=DESTROYED
;   dx=DESTROYED

		mov	dx, bx
		mov	bl, bh
		call	DisplayByte
		mov	bx, dx
		jmp	DisplayByte
ENDP

PUBLIC	StatusWord
PROC	StatusWord
		call	TextVidBase
		mov	di, 20
		mov	bx, cx
		mov	ah, 3fh
		jmp	DisplayShort
ENDP

PROC    EditShort
; EditShort - allow user to change a 16-bit value as onscreen hex
;   ah=attributes, al=DESTROYED
;   bx=number to edit
;   di=location on screen- INCREMENTED
;   cx,dx=DESTROYED

		mov	[attr], ah
		mov	[temp2], bx
		mov	[temp], di
		call	DisplayShort

		mov	ax, [temp]
		shr	ax, 1
		mov	[temp], di

@@Cur:		xor	dx, dx
		mov	bx, 80
		div	bx
		mov	dh, al
		add	dl, 3		; cursor to right of num
		mov	ah, 02h
		mov	bh, 00h
		int	10h			; cursor gotoxy

; loop and modify temp2
@@Select:	xor	ah, ah			; get a key
		int	16h
		mov	[word keyhit], ax

		cmp	al, '0'
		jae	@@Digit1
		jmp	@@Bail

@@Digit1:	cmp	al, '9'
		jbe	@@DecDigit
		cmp	al, 'a'
		jae	@@Hex1

@@DecDigit:	sub	al, '0'
@@AnyDigit:	shl	[word temp2], 4
		or	[byte temp2], al

		mov	bx, [temp2]
		mov	ax, [temp]
		sub	ax, 8
		mov	di, ax
		mov	ah, [attr]
		call	DisplayShort

		jmp	@@Select

@@Hex1:		cmp	al, 'f'
		jbe	@@HexDigit
		jmp	@@Select
@@HexDigit:	sub	al, ('a'-10)
		jmp	@@AnyDigit

;		mov	bx, ax
;		mov	ah, 07h
;		mov	di, 140
;		call	DisplayShort

@@Bail:		mov	di, [temp]		; restore registers
		mov	bx, [temp2]
		ret
ENDP

PROC    EditString
; EditString - allow user to change a string onscreen
;   ah=attributes, al=DESTROYED
;   cx=length
;   di=location on screen
;   bx,dx=DESTROYED

		mov	[attr], ah
		mov	[temp], di
		mov	[templen], cx

		mov	dx, 0

@@Cur:		mov	ax, [temp]
		shr	ax, 1
		add	ax, dx
		mov	[temp2], dx

		xor	dx, dx
		mov	bx, 80
		div	bx
		mov	dh, al
		mov	ah, 02h
		mov	bh, 00h
		int	10h			; cursor gotoxy

; loop and modify temp2
@@Select:	xor	ah, ah			; get a key
		int	16h
		mov	[word keyhit], ax

		cmp	ax, 4b00h
		jne	@@Next1

		mov	dx, [temp2]
		cmp	dx, 0
		je	@@CarryOn
		dec	dx
		jmp	@@CarryOn

@@Next1:	cmp	ax, 4d00h
		jne	@@Next2

		mov	dx, [temp2]
		inc	dx
		jmp	@@CarryOn

@@Next2:	cmp	al, 13
		je	@@Bail

;		mov	bx, ax
;		mov	ah, 07h
;		mov	di, 140
;		call	DisplayShort

		mov	dx, [temp2]
		shl	dx, 1
		mov	di, [temp]
		add	di, dx
		mov	ah, [attr]
		mov	[word es:di], ax

		mov	dx, [temp2]
		inc	dx
@@CarryOn:	mov	cx, [templen]
		cmp	dx, cx
		je	@@Bail

		jmp	@@Cur

@@Bail:		mov	di, [temp]		; restore registers
		mov	bx, [temp2]
		ret
ENDP

PUBLIC	WriteIntr
PROC	WriteIntr
;	cl = interrupt number
;	es:di = pointer to interrupt handler routine
;	ax,bx,cx=DESTROYED

		xor	bh, bh
		mov	bl, cl
		shl	bx, 2		; bx = zero page intr loc

		mov	cx, es
		xor	ax, ax
		mov	es, ax

		cli			; disable interrupts
					; poke vector into zero page

		mov	[word es:0000h + bx], di
		mov	[word es:0002h + bx], cx

		sti			; enable interrupts

		ret
ENDP

PUBLIC	ReadIntr
PROC	ReadIntr
;	cl = interrupt number
;	ax,bx=DESTROYED
; RETURNS:
;	es:di = pointer to ISR


		xor	bh, bh
		mov	bl, cl
		shl	bx, 2		; bx = zero page intr loc
					; peek vector from zero page

		xor	ax, ax
		mov	es, ax

		mov	di, [word es:0000h + bx]
		mov	ax, [word es:0002h + bx]

		mov	es, ax
		ret
ENDP

PUBLIC	PlugClock
PROC	PlugClock

		call	WorkLight

		mov	cl, 1ch
		call	ReadIntr

		mov	ax, es
		mov	[word timerSegment], ax
		mov	[word timerOffset], di

		mov	ax, cs
		mov	es, ax
		mov	di, offset ClockISR
		mov	cl, 1ch		; user clock interrupt
		call	WriteIntr

		call	OKLight

		ret
ENDP

PUBLIC	UnplugClock
PROC	UnplugClock

		call	WorkLight
		mov	ax, [word timerSegment]
		cmp	ax, 0
		je	@@Fail
		mov	[word timerSegment], 0
		mov	es, ax
		mov	di, [word timerOffset]
		mov	cl, 1ch		; user clock interrupt
		call	WriteIntr
		call	OKLight
		ret
@@Fail:		jmp	BadLight
ENDP

PUBLIC	ClockISR
PROC	ClockISR
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	es
		push	di

		mov	ax, 0040h
		mov	ds, ax
		mov	cx, [word 006ch]
		mov	ax, cs
		mov	ds, ax
		call	StatusWord

		pop	di
		pop	es
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax

		iret
ENDP

PUBLIC	PlugBreak
PROC	PlugBreak

		call	WorkLight

		mov	cl, 1bh
		call	ReadIntr

		mov	ax, es
		mov	[word breakSegment], ax
		mov	[word breakOffset], di

		mov	ax, cs
		mov	es, ax
		mov	di, offset BreakISR
		mov	cl, 1bh		; user clock interrupt
		call	WriteIntr

		call	OKLight

		ret
ENDP

PUBLIC	UnplugBreak
PROC	UnplugBreak

		call	WorkLight
		mov	ax, [word breakSegment]
		cmp	ax, 0
		je	@@Fail
		mov	[word breakSegment], 0
		mov	es, ax
		mov	di, [word breakOffset]
		mov	cl, 1bh		; user clock interrupt
		call	WriteIntr
		jmp	OKLight
@@Fail:		jmp	BadLight
ENDP

PUBLIC	BreakISR
PROC	BreakISR

;	This is a *very* special kind of ISR; it takes a very
;	proactive approach to resetting BefOS.

		mov	ax, cs
		mov	ds, ax

		call	UnplugClock
		;call	UnplugCom
		call	UnplugBreak
		call	UnplugPrtSc

		xor	al, al
		mov	[byte bits], al		; clear modes

		sti

;	At this point, we can't even get back to the caller,
;	so dismiss the idea of ending this with 'iret' or 'retf'.
;	Instead we shall use a far jump.

		jmp	far	Start

ENDP

PUBLIC	PlugPrtSc
PROC	PlugPrtSc

		call	WorkLight

		mov	cl, 05h
		call	ReadIntr

		mov	ax, es
		mov	[word prtscSegment], ax
		mov	[word prtscOffset], di

		mov	ax, cs
		mov	es, ax
		mov	di, offset PrtScISR
		mov	cl, 05h		; prtsc interrupt
		call	WriteIntr

		call	OKLight

		ret
ENDP

PUBLIC	UnplugPrtSc
PROC	UnplugPrtSc

		call	WorkLight
		mov	ax, [word prtscSegment]
		cmp	ax, 0
		je	@@Fail
		mov	[word prtscSegment], 0
		mov	es, ax
		mov	di, [word prtscOffset]
		mov	cl, 05h		; prtsc interrupt
		call	WriteIntr
		call	OKLight
		ret
@@Fail:		jmp	BadLight
ENDP

PUBLIC	PrtScISR
PROC	PrtScISR
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	es
		push	di

		mov	cx, 1234h
		call	CustomLight

		pop	di
		pop	es
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax

		iret
ENDP

end             MAIN
